<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>アドオン翻訳支援パック生成ツール</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
body {
  font-family: sans-serif;
  padding: 20px;
}
#downloadLink {
  font-size: 18px;
  color: blue;
}
</style>
</head>
<body>

<h2>アドオン翻訳支援パック生成ツール</h2>

<p>マイクラ統合版アドオン（.mcaddon / .mcpack）を選択してください：</p>
<input type="file" id="addonInput" accept=".mcaddon,.mcpack,.zip">

<button id="buildBtn" style="margin-left:10px;">翻訳パックを生成</button>

<div id="status" style="margin-top:20px;color:#444;"></div>

<script>
// -----------------------------------------------------
// 辞書の読み込み（サーバー上の pokemonDict.json を使用）
// -----------------------------------------------------
let pokemonDict = {};
let manifestTemplate = {};

async function loadExternalFiles() {
    try {
        const dictRes = await fetch("./pokemonDict.json");
        pokemonDict = await dictRes.json();

        const maniRes = await fetch("./manifestTemplate.json");
        manifestTemplate = await maniRes.json();

        console.log("辞書・テンプレート読み込み完了！");
    } catch (err) {
        console.error("辞書 or テンプレート読み込み失敗", err);
        alert("辞書またはテンプレートが読み込めませんでした。ファイルを同じフォルダに置いてね。");
    }
}
loadExternalFiles();


// -----------------------------------------------------
// UUID 生成
// -----------------------------------------------------
function uuid() {
    // return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
    //    const r = Math.random() * 16 | 0;
    //    return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
    //});
    return crypto.randomUUID();
}


// -----------------------------------------------------
// ZIP 内の全階層を再帰して .lang を探す
// -----------------------------------------------------
async function extractLangFiles(mainZip) {
    const langFiles = [];
    
    // 1) 再帰的に mcpack を探して解凍
    async function loadPack(zip) {
        // パック内の .lang を検索
        zip.forEach((relativePath, file) => {
            if (!file.dir && /texts\/.*\.lang$/.test(relativePath)) {
                langFiles.push({
                    path: relativePath,
                    file: file
                });
            }
        });
        
        // 次に、内部に .mcpack が入っている場合は再帰
        const packPromises = [];
        zip.forEach((relativePath, file) => {
            if (relativePath.endsWith(".mcpack") || relativePath.endsWith(".zip")) {
                packPromises.push(
                    file.async("blob").then(blob => JSZip.loadAsync(blob))
                );
            }
        });
        
        // 再帰的に mcpack をロード
        const innerZips = await Promise.all(packPromises);
        for (const inner of innerZips) {
            await loadPack(inner);
        }
    }
    
    await loadPack(mainZip);
    return langFiles;
}


// -----------------------------------------------------
// 言語ファイルの翻訳（定義文字列のみ置換）
// -----------------------------------------------------
const status = document.getElementById("status");

function translateLang(text) {
    const lines = text.split(/\r?\n/);
    const out = [];
    
    for (let line of lines) {
        const eqIndex = line.indexOf("=");
        
        if (eqIndex <= 0) {
            out.push(line);
            continue;
        }
        
        const key = line.slice(0, eqIndex);
        let value = line.slice(eqIndex + 1);
        const trimmed = value.trim();
        
        if (pokemonDict[trimmed] !== undefined) {
            value = pokemonDict[trimmed];
        }
        
        // 確認用に画面に出力
        status.textContent += `"${trimmed}" → "${value}"\n`;
        
        out.push(`${key}=${value}`);
    }
    
    return out.join("\n");
}

// -----------------------------------------------------
// 生成した ZIP をダウンロードリンクとして生成（スマホ対応）
// -----------------------------------------------------
function createDownloadLink(blob) {
    const url = URL.createObjectURL(blob);

    // 古いリンクがあれば削除
    let old = document.getElementById("downloadLink");
    if (old) old.remove();

    const a = document.createElement("a");
    a.id = "downloadLink";
    a.href = url;
    a.download = "TranslationPK.mcpack";
    a.textContent = "翻訳パックをダウンロード";
    a.style.display = "block";
    a.style.marginTop = "20px";

    document.body.appendChild(a);

    // スマホのため自動クリック
    setTimeout(() => a.click(), 300);
}


// -----------------------------------------------------
// メイン：翻訳パック生成
// -----------------------------------------------------
document.getElementById("buildBtn").onclick = async () => {
    const input = document.getElementById("addonInput");
    if (!input.files.length) {
        alert("アドオンファイルを選択してください！");
        return;
    }
    const addonFile = input.files[0];
    
    document.getElementById("status").textContent = "読み込み中…";
    
    try {
        const buffer = await addonFile.arrayBuffer();
        const zip = await JSZip.loadAsync(buffer);
        
        document.getElementById("status").textContent = "langファイル捜索…";
        
        // ★★★ 修正ポイント ★★★
        const langFiles = await extractLangFiles(zip);
        
        if (langFiles.length === 0) {
            document.getElementById("status").textContent = "言語ファイルが見つかりませんでした…";
            return;
        }
        
        const langInfo = langFiles[0];
        const origText = await langInfo.file.async("string");
        const translated = translateLang(origText);
        
        const outZip = new JSZip();
        
        const manifest = {
            ...manifestTemplate,
            header: { ...manifestTemplate.header, uuid: uuid() },
            modules: manifestTemplate.modules.map(m => ({ ...m, uuid: uuid() }))
        };
        
        outZip.file("manifest.json", JSON.stringify(manifest, null, 2));
        outZip.file("texts/ja_JP.lang", translated);
        
        const blob = await outZip.generateAsync({ type: "blob" });
        createDownloadLink(blob);
        
        document.getElementById("status").textContent = "生成完了！";
        
    } catch (err) {
        console.error(err);
        document.getElementById("status").textContent = "解析に失敗しました…";
    }
};
</script>

</body>
</html>